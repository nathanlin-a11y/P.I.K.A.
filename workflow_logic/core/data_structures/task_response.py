from __future__ import annotations
from typing import Optional, Literal, Dict, Any, List, TYPE_CHECKING
from pydantic import Field
from workflow_logic.core.data_structures.base_models import BaseDataStructure
from workflow_logic.core.data_structures.central_types import OutputInterfaceType

if TYPE_CHECKING:
    from workflow_logic.core.data_structures.output_interfaces import OutputInterface, StringOutput, LLMChatOutput, SearchOutput, WorkflowOutput

class TaskResponse(BaseDataStructure):
    task_id: Optional[str] = Field(None, description="The id of the task")
    task_name: str = Field(..., description="The name of the task")
    task_description: str = Field(..., description="A detailed description of the task")
    status: Literal["pending", "complete", "failed"] = Field(..., description="The current status of the task")
    result_code: int = Field(..., description="The result code indicating the success or failure of the task")
    result_diagnostic: Optional[str] = Field(None, description="Diagnostic information for the task, if any")
    task_inputs: Optional[Dict[str, Any]] = Field(None, description="The inputs provided to the task")
    usage_metrics: Optional[Dict[str, Any]] = Field(None, description="Usage metrics for the task, like generated tokens, time taken, and cost.")
    execution_history: Optional[List[Dict[str, Any]]] = Field(None, description="Execution history of the task")
    task_outputs: Optional[str] = Field(None, description="The output generated by the task")
    task_content: Optional[OutputInterfaceType] = Field(None, description="An outputinterface with the content of the task output")

    def __str__(self) -> str:
        return f"{self.task_name}: {self.task_description}\nTask Output:\n{self.task_outputs}"
    
    def model_dump(self, *args, **kwargs):
        data = super().model_dump(*args, **kwargs)
        from workflow_logic.core.data_structures.output_interfaces import OutputInterface
        if self.task_content and isinstance(self.task_content, OutputInterface):
            data['task_content'] = self.task_content.model_dump(*args, **kwargs)
        return data
    
class DatabaseTaskResponse(TaskResponse):
    task_content: Optional[Dict[str, Any]] = Field(None, description="The content of the task output, represents the model_dump of the OutputInterface used")
    
    def retrieve_task_content(self) -> OutputInterfaceType:
        if not self.task_content:
            return StringOutput([self.task_outputs])
        from workflow_logic.core.data_structures.output_interfaces import StringOutput, LLMChatOutput, SearchOutput, WorkflowOutput
        output_type = self.task_content.get("output_type")
        if output_type == "StringOutput":
            return StringOutput(**self.task_content)
        elif output_type == "LLMChatOutput":
            return LLMChatOutput(**self.task_content)
        elif output_type == "SearchOutput":
            return SearchOutput(**self.task_content)
        elif output_type == "WorkflowOutput":
            return WorkflowOutput(**self.task_content)
        else:
            return StringOutput([self.task_outputs])
    
    def retrieve_task_response(self) -> TaskResponse:
        return TaskResponse(
            task_id=self.task_id,
            task_name=self.task_name,
            task_description=self.task_description,
            status=self.status,
            result_code=self.result_code,
            task_outputs=self.task_outputs,
            task_content=self.retrieve_task_content(),
            result_diagnostic=self.result_diagnostic,
            task_inputs=self.task_inputs,
            usage_metrics=self.usage_metrics,
            execution_history=self.execution_history
        )
    
    @classmethod
    def model_validate(cls, obj):
        if isinstance(obj, dict) and 'task_content' in obj and isinstance(obj['task_content'], OutputInterface):
            obj = obj.copy()
            obj['task_content'] = obj['task_content'].model_dump()
        return super().model_validate(obj)