import logging
from typing import List, Tuple, Optional, Union
from pydantic import BaseModel, Field, ConfigDict
from autogen.code_utils import extract_code
from autogen.agentchat import ConversableAgent
from workflow_logic.core.communication import DatabaseTaskResponse, MessageDict
from workflow_logic.util.utils import get_language_matching

class ChatExecutionFunctionality(BaseModel):
    llm_agent: ConversableAgent = Field(..., description="The LLM agent")
    execution_agent: ConversableAgent = Field(..., description="The execution agent")
    functions: Optional[List[dict]] = Field(None, description="List of function definitions")
    code_execution_config: Union[bool, dict] = Field(False, description="Code execution configuration")
    max_recursion_depth: int = Field(5, description="Maximum number of recursive calls allowed in a single turn")
    valid_languages: List[str] = Field(["python", "shell"], description="A list of valid languages for code execution")
    return_output_to_agent: bool = Field(True, description="Whether to return tool/code outputs to the agent")

    model_config = ConfigDict(arbitrary_types_allowed=True)

    def setup_agents(self):
        if self.functions:
            for func in self.functions:
                self.llm_agent.register_function(func)

    def take_turn(self, messages: List[MessageDict]) -> Tuple[List[MessageDict], bool]:
        self.setup_agents()
        new_messages = []
        is_terminated = False
        recursion_depth = 0

        while recursion_depth < self.max_recursion_depth:
            chat_response = self.llm_agent.generate_reply(messages + new_messages)

            if not chat_response:
                logging.warning("No response generated by LLM agent.")
                break

            if isinstance(chat_response, dict) and chat_response.get("function_call"):
                function_messages = self.handle_function_call(chat_response)
                new_messages.extend(function_messages)
                if not self.return_output_to_agent:
                    break
            elif isinstance(chat_response, str):
                new_messages.append(MessageDict(role="assistant", content=chat_response, generated_by="llm", type="text"))
                code_messages = self.handle_potential_code_execution(chat_response)
                if code_messages:
                    new_messages.extend(code_messages)
                    if not self.return_output_to_agent:
                        break
                else:
                    # If no code execution, end the turn
                    break
            else:
                logging.warning(f"Unexpected response format: {chat_response}")
                break

            if new_messages and "TERMINATE" in new_messages[-1].content:
                is_terminated = True
                break

            recursion_depth += 1

        return new_messages, is_terminated

    def handle_function_call(self, response: dict) -> List[MessageDict]:
        function_call = response["function_call"]
        function_name = function_call["name"]
        function_args = function_call["arguments"]

        new_messages = [
            MessageDict(
                role="assistant",
                content=f"Calling function {function_name} with arguments: {function_args}",
                generated_by="llm",
                step=function_name,
                type="text"
            )
        ]
        
        is_success, result = self.execution_agent.execute_function(function_call)
        
        if is_success and isinstance(result, dict) and 'content' in result:
            content = result['content']
            if isinstance(content, DatabaseTaskResponse):
                new_messages.append(MessageDict(
                    role="tool",
                    content=str(content),
                    generated_by="tool",
                    step=function_name,
                    type="TaskResponse",
                    task_responses=[content]
                ))
            else:
                new_messages.append(MessageDict(
                    role="tool",
                    content=str(content),
                    generated_by="tool",
                    step=function_name,
                    type="text"
                ))
        else:
            error_message = f"Error executing function: {result}"
            new_messages.append(MessageDict(
                role="tool",
                content=error_message,
                generated_by="tool",
                step=function_name,
                type="text"
            ))
        
        return new_messages

    def handle_potential_code_execution(self, response: str) -> List[MessageDict]:
        code_blocks = self.retrieve_code_blocks(response)
        if not code_blocks:
            return []

        if self.code_execution_config:
            logging.info(f"Executing code blocks: {code_blocks}")
            is_success, result = self.execution_agent.execute_code_blocks(code_blocks)
            
            if is_success and isinstance(result, dict) and 'content' in result:
                content = result['content']
                if isinstance(content, DatabaseTaskResponse):
                    return [MessageDict(
                        role="tool",
                        content=str(content),
                        generated_by="tool",
                        step="code_execution",
                        type="TaskResponse",
                        task_responses=[content]
                    )]
                else:
                    return [MessageDict(
                        role="tool",
                        content=f"Code execution result: {content}",
                        generated_by="tool",
                        step="code_execution",
                        type="text"
                    )]
            else:
                error_message = f"Error executing code: {result}"
                return [MessageDict(
                    role="tool",
                    content=error_message,
                    generated_by="tool",
                    step="code_execution",
                    type="text"
                )]
        
        return []
        
    def chat(self, initial_message: str, max_turns: int = 1) -> List[MessageDict]:
        messages = [MessageDict(role="user", content=initial_message)]
        
        for _ in range(max_turns):
            new_messages, is_terminated = self.take_turn(messages)
            messages.extend(new_messages)
            
            if is_terminated:
                break
        
        return messages
    
    def retrieve_code_blocks(self, content: str) -> List[Tuple[str, str]]:
        extracted_code = extract_code(content)
        if not extracted_code:
            return []

        valid_code_blocks = []
        unsupported_languages = set()
        for lang, code in extracted_code:
            matched_language = get_language_matching(lang)
            if matched_language in self.valid_languages:
                valid_code_blocks.append((matched_language, code))
            else:
                unsupported_languages.add(lang)
        
        if unsupported_languages:
            logging.warning(f"Removed code blocks with unsupported languages: {', '.join(unsupported_languages)}")
        
        return valid_code_blocks